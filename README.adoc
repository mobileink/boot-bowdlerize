= boot-bowdlerize

Thomas Bowdler infamously excised the naughty bits in Shakespeare,
producing a sanitized -- _bowdlerized_ -- version of the Bard for
children and the those whose sensibilities were offended by obscene
language.  `boot-bowdlerize` tries to do the same for `bower`,
excising those nasty bits bits of Javascript and JSON to produce a
Clojurized version suitable for those offended by obscene languages.

`boot-bowdlerize` is not tied to bower, however.  It's really a an
implementation of a simple technique for generating namespaced runtime
configuration information at build-time.

== motivation

Webapp development requires coordination between filesystem
configuration (location and structure of resource directories, etc.)
and app configuration (using filesystem paths in <link> elements, for
example.)  You might also want to use build config info at runtime,
e.g. you might want to have an `admin` webpage that dumps version info
about dependencies, tools, etc. used to build the app.

Goals:

* use indirection, so e.g. if you change your filesystem layout you only have to change config info in one place

* keep all config info in one place at build time, but:

* use namespaces to partition runtime config data, rather than putting
  everything into on giant config map

* make config info available at both build time and compile time

* dynamically generate runtime config info at build time where possible, e.g. pull version info from resource metadata instead of hardcoding it

* etc.

== usage

Fork/clone this project, install `tasklib`, and build and run `jetty`.
See the READMEs in those subdirs.

The basic idea is that we define config data in ordinary clojure
namespaces (source files), and at build time we use those namespaces
to generate runtime config source files.  One way to do this,
illustrated by the testapps in this project, is to use a `config`
directory on the classpath to hold build-time config specs.


=== bower

An example of such a file for bower resources follows.
`boot-bowdlerize` uses the bower package name to install it and read
its metadata, so our config maps uses package names as keys.  You can
use any names for both namespace and interned syms; you will list them
in your `build.boot` file, as explained below.  In this example, the
`moment` package metadata has enough information for use to extract
the resource URI automatically, so all we need to provide is the
symbol we want to use for it at runtime.  But the `materialize`
package bundles several components, and its metadata is not
sufficiently rich to support inference to their URIs.  So we have to
explicitly indicate them in the `:bundles` maps.

[source,clojure]
.bower.clj
----
(ns bower)

(def config-map
  [{:bower "moment"
    :runtime 'hello.scripts/moment}
   {:bower "materialize"
    :bundles [{:runtime 'hello.styles/materialize
               :uri "bower_components/Materialize/bin/materialize.css"}
              {:runtime 'hello.scripts/materialize
               :uri "bower_components/Materialize/bin/materialize.js"}]}])
----

=== polymer

`boot-bowdlerize` began life as a tool to help write
https://www.polymer-project.org/1.0/[Polymer] webapps in Clojure.  A
config map for Polymer resources looks just like one for bower
resources, except `:polymer` replaces `:bower`, and for bundles a
`:kw` entry must be supplied.  The latter ensures correct mapping from
the user-specified `:runtime` symbol for the component and its HTML
tag.

[source,clojure]
.polymer.clj
----
(ns polymer)

(def config-map
  [{:polymer "PolymerElements/iron-icon" :runtime 'miraj.iron/icon}
   {:polymer "PolymerElements/paper-button" :runtime 'miraj.paper/button}
   {:polymer "PolymerElements/paper-input"
    :bundles [{:runtime 'miraj.paper/input
               :kw :paper-input
               :uri "bower_components/paper-input/paper-input.html"}
              {:runtime 'miraj.paper.input/textarea
               :kw :paper-textarea
               :uri "bower_components/paper-input/paper-textarea.html"}
              {:runtime 'miraj.paper.input/behavior
               :kw :paper-input-behavior
               :uri "bower_components/paper-input/paper-input-behavior.html"}
              {:runtime 'miraj.paper.input/container
               :kw :paper-input-container
               :uri "bower_components/paper-input/paper-input-container.html"}
              {:runtime 'miraj.paper.input/error
               :kw :paper-input-error
               :uri "bower_components/paper-input/paper-input-error.html"}
              {:runtime 'miraj.paper.input/addon-behavior
               :kw :paper-input-addon-behavior
               :uri "bower_components/paper-input/paper-input-addon-behavior.html"}
              {:runtime 'miraj.paper.input/char-counter
               :kw :paper-input-char-counter
               :uri "bower_components/paper-input/paper-input-char-counter.html"}]}])
----

A sample Polymer app is under construction.

=== non-bower

You can also specify resources that do not rely on bower, e.g.

[source,clojure]
.resources.clj
----
(ns resources)
(def scripts
  [{:runtime 'hello.scripts/jquery
    :uri "https://code.jquery.com/jquery-2.1.1.min.js"}])
(def statics
  [{:runtime 'hello.resources/statics :uri "target"}])
(def styles
  [{:runtime 'hello.styles/app :uri "styles/app.css"}
   {:runtime 'hello.scripts/app :uri "scripts/app.js"}])
----

Here `resources/statics` is an example of using the `bowdlerize`
mechanism to specify a runtime configuration parameter rather than a
web resource.  In this case, our `jetty` testapp handler uses
`hello.resources/statics` to set the `:root` parameter of the
`route/files` function to "target".

You can organize your config maps however you please; for example
here's the same info, reorganized:

[source,clojure]
.hello-stuff.clj
----
(ns resources)
(def scripts
  [{:runtime 'hello.scripts/jquery :uri "https://code.jquery.com/jquery-2.1.1.min.js"}
   {:runtime 'hello.scripts/app :uri "scripts/app.js"}])
(def statics
  [{:runtime 'hello.resources/statics :uri "target"}])
(def styles
  [{:runtime 'hello.styles/app :uri "styles/app.css"}])
----

Notice that in the above example three runtime namespaces were used,
`hello.scripts`, `hello.styles`, and `hello.resources`.  You can use
any namespace, anywhere in any config file.  When `boot-bowlderize`
processes your build-time config files, it will merge them
appropriately, so in this case it will produce three runtime config
files:

[source,clojure]
.hello/resources.clj
----
(ns hello.resources)
(def statics {:uri "target"})
----

[source,clojure]
.hello/scripts.clj
----
(ns hello.scripts)
(def materialize {:uri "bower_components/Materialize/bin/materialize.js" :type :js})
(def moment {:uri "bower_components/moment/moment.js" :type :js})
(def app {:uri "scripts/app.js" :type :js})
(def jquery {:uri "https://code.jquery.com/jquery-2.1.1.min.js" :type :js})
----

[source,clojure]
.hello/styles.clj
----
(ns hello.styles)
(def materialize {:uri "bower_components/Materialize/bin/materialize.css" :type :css})
(def app {:uri "styles/app.css" :type :css})
----

You configure `boot-bowdlerize` to put these somewhere on your runtime
classpath so they become available to your app.  The default setting
puts them in `target/classes`.

=== build.boot

Here's how you configure your `build.boot`:

[source,clojure]
.build.boot
----
:dependencies '[ ... [mobileink/boot-bowdlerize "0.1.0-SNAPSHOT" :scope "test"] ...]
(require '[boot-bowdlerize :as b] ...)
;; define the set of config data vars; must be on build-time classpath
(def configs #{'resources/styles 'resources/scripts 'resources/statics 'bower/config-map})
;; pass the vars to bowdlerize tasks
(task-options!
 b/config {:nss configs}
 b/config-rm {:nss configs}  ;; prevents the buildtime sources from being copied to target
 b/install {:nss configs}
 ...
----

=== runtime

You're generating source files so you have to make sure to set your classpath correctly.
